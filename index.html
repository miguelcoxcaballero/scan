<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scanner Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#131314">
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

  <style>
    :root {
      /* --- LIGHT THEME --- */
      --md-sys-color-primary: #0b57d0;
      --md-sys-color-on-primary: #ffffff;
      --md-sys-color-primary-container: #d3e3fd;
      --md-sys-color-on-primary-container: #041e49;
      --md-sys-color-secondary-container: #c2e7ff;
      --md-sys-color-on-secondary-container: #001d35;
      --md-sys-color-error: #ba1a1a;
      --surface-1: #ffffff;
      --surface-2: #f0f4f9;
      --surface-3: #f8fafd;
      --outline: #747775;
      --outline-variant: #c4c7c5;
      --text-main: #1f1f1f;
      --text-sub: #444746;
      --grid-color: #e0e0e0;
      --shadow-color: rgba(0,0,0,0.08);
      --ease-spring: cubic-bezier(0.2, 0.0, 0, 1.0);
      
      --ease-slide: cubic-bezier(0.2, 0.8, 0.2, 1); 

      /* The visible height of the "hidden" menu */
      --mobile-sheet-header-height: 160px;
    }

    /* --- DARK THEME --- */
    body.dark-mode {
      --md-sys-color-primary: #8AB4F8;
      --md-sys-color-on-primary: #062e6f;
      --md-sys-color-primary-container: #004A77;
      --md-sys-color-on-primary-container: #C2E7FF;
      --md-sys-color-secondary-container: #004a77;
      --md-sys-color-on-secondary-container: #c2e7ff;
      --surface-1: #1E1F20; 
      --surface-2: #1E1F20; 
      --surface-3: #131314; 
      --outline: #8E918F;
      --outline-variant: #444746;
      --text-main: #E8EAED;
      --text-sub: #9AA0A6;
      --grid-color: #333;
      --shadow-color: rgba(0,0,0,0.6);
    }

    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
      outline: none; 
      -webkit-tap-highlight-color: transparent; 
    }
    
    body {
      height: 100vh;
      width: 100vw;
      display: flex;
      background-color: var(--surface-3);
      color: var(--text-main);
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
      transition: background-color 0.3s ease;
    }

    .hidden { display: none !important; }
    
    /* --- LOADING --- */
    #appLoading {
      position: fixed; inset: 0; background: var(--surface-3); z-index: 9999;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: opacity 0.4s;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid var(--outline);
      border-top-color: var(--md-sys-color-primary); border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 16px;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    /* --- LANDING PAGE --- */
    #landingPage {
      position: fixed; inset: 0; z-index: 500;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: var(--surface-3);
      transition: opacity 0.5s var(--ease-spring), transform 0.5s var(--ease-spring);
      padding: 24px;
    }
    
    .hero-content {
      text-align: center;
      display: flex; flex-direction: column; align-items: center; gap: 24px;
      animation: heroEnter 0.8s var(--ease-spring);
      width: 100%; max-width: 600px;
    }
    
    @keyframes heroEnter {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hero-icon { font-size: 64px; color: var(--md-sys-color-primary); margin-bottom: 8px; }
    .hero-title { font-family: 'Google Sans', sans-serif; font-size: 44px; font-weight: 400; color: var(--text-main); margin: 0; }
    .hero-sub { font-size: 16px; color: var(--text-sub); margin-top: -16px; margin-bottom: 16px; }

    /* Hero Buttons & Dropdown Container */
    .hero-actions {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn-hero {
      height: 56px; padding: 0 32px; border-radius: 28px;
      background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary);
      border: none; font-family: 'Google Sans', sans-serif; font-size: 16px; font-weight: 500;
      cursor: pointer; display: flex; align-items: center; gap: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      white-space: nowrap;
    }
    .btn-hero:hover { transform: scale(1.02); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
    .btn-hero:active { transform: scale(0.98); }

    .btn-hero.secondary {
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
    }

    /* DROPDOWN STYLES */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 160px;
      background-color: var(--surface-1);
      border-radius: 12px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      z-index: 1000;
      margin-top: 8px;
      padding: 8px 0;
      overflow: hidden;
      transform-origin: top left;
      animation: menuFadeIn 0.2s ease-out;
    }

    @keyframes menuFadeIn {
      from { opacity: 0; transform: scaleY(0.8); }
      to { opacity: 1; transform: scaleY(1); }
    }

    .dropdown.show .dropdown-content {
      display: block;
    }

    .dropdown-item {
      padding: 12px 24px;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-main);
      cursor: pointer;
      font-family: 'Google Sans', sans-serif;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
      background: transparent;
      border: none;
      width: 100%;
      text-align: left;
    }
    .dropdown-item:hover {
      background-color: var(--surface-2);
    }
    .dropdown-item span {
      font-size: 20px;
      color: var(--md-sys-color-primary);
    }

    /* --- NAMING MODAL --- */
    #modalOverlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 600;
      display: none; align-items: center; justify-content: center;
      backdrop-filter: blur(4px); opacity: 0; transition: opacity 0.3s;
      padding: 16px;
    }
    #modalOverlay.open { display: flex; opacity: 1; }
    
    .modal-card {
      background: var(--surface-1); width: 100%; max-width: 400px; padding: 24px; border-radius: 28px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      transform: scale(0.9); opacity: 0; transition: 0.3s var(--ease-spring);
      display: flex; flex-direction: column; gap: 24px;
    }
    #modalOverlay.open .modal-card { transform: scale(1); opacity: 1; }

    .modal-title { font-family: 'Google Sans'; font-size: 24px; color: var(--text-main); }
    
    .input-group { position: relative; }
    .mat-input {
      width: 100%; height: 56px; border: 1px solid var(--outline-variant);
      border-radius: 4px; background: transparent; padding: 0 16px;
      color: var(--text-main); font-size: 16px; transition: 0.2s;
    }
    .mat-input:focus { border-color: var(--md-sys-color-primary); border-width: 2px; padding: 0 15px; }
    .input-label {
      position: absolute; left: 12px; top: -10px; background: var(--surface-1);
      padding: 0 4px; font-size: 12px; color: var(--md-sys-color-primary);
    }
    
    .modal-actions { display: flex; justify-content: flex-end; gap: 12px; }
    .btn-text {
      height: 40px; padding: 0 12px; border: none; background: transparent;
      color: var(--md-sys-color-primary); font-family: 'Google Sans'; font-weight: 500;
      cursor: pointer; border-radius: 20px; transition: 0.2s;
    }
    .btn-text:hover { background: rgba(0,0,0,0.05); }
    .btn-fill {
      height: 40px; padding: 0 24px; border: none; border-radius: 20px;
      background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary);
      font-family: 'Google Sans'; font-weight: 500; cursor: pointer; transition: 0.2s;
    }
    .btn-fill:hover { filter: brightness(1.1); }

    /* --- MAIN APP LAYOUT --- */
    #appContainer {
      flex: 1; display: flex; padding: 12px; gap: 16px;
      width: 100vw;
      height: 100%;
      opacity: 0; transform: scale(0.98);
      transition: opacity 0.6s 0.2s, transform 0.6s 0.2s var(--ease-spring);
    }
    #appContainer.active { opacity: 1; transform: scale(1); }

    /* --- LEFT PANEL (PREVIEW) --- */
    #mainPanel {
      flex: 1; display: flex; flex-direction: column;
      background-color: var(--surface-3);
      border-radius: 16px;
      overflow: hidden; position: relative;
    }

    #toolbar {
      height: 64px; display: flex; align-items: center; justify-content: space-between; 
      padding: 0 8px; margin-bottom: 8px; flex-shrink: 0;
    }

    .doc-title {
      background: transparent; border: none; color: var(--text-main);
      font-family: 'Google Sans', sans-serif; font-size: 18px; padding: 8px 12px;
      border-radius: 8px; width: 300px; transition: 0.2s;
    }
    .doc-title:hover { background: var(--surface-1); }
    .doc-title:focus { background: var(--surface-1); border: 1px solid var(--md-sys-color-primary); }

    .actions { display: flex; gap: 8px; align-items: center; }
    
    .btn-icon {
      width: 44px; height: 44px; border-radius: 50%; border: none;
      background: transparent; color: var(--text-sub); cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: 0.2s;
    }
    .btn-icon:hover { background: var(--surface-1); color: var(--text-main); }

    .btn-chip {
      height: 40px; padding: 0 16px; border-radius: 20px; 
      border: 1px solid var(--outline); background: transparent; color: var(--text-main);
      display: flex; align-items: center; gap: 8px; font-family: 'Google Sans', sans-serif; font-size: 13px; font-weight: 500;
      cursor: pointer; transition: 0.2s; white-space: nowrap;
    }
    .btn-chip:hover { background: var(--surface-1); }
    .btn-chip.active { background: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); border-color: transparent; }
    .btn-chip:disabled { opacity: 0.4; cursor: not-allowed; border-color: var(--outline-variant); }

    /* --- PREVIEW CONTAINER --- */
    #viewport {
      flex: 1; display: flex; align-items: center; justify-content: center;
      background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
      background-size: 24px 24px;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      min-height: 0;
      touch-action: none;
    }

    #paper {
      background: white;
      box-shadow: 0 4px 20px var(--shadow-color);
      position: relative;
      display: none;
      transform-origin: center center;
      transition: transform 0.05s linear;
    }

    #previewImg {
      display: block; width: 100%; height: 100%; object-fit: contain; pointer-events: none;
    }
    
    .layer-canvas {
      position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;
    }
    #cropLayer { cursor: crosshair; pointer-events: auto; display: none; touch-action: none; }
    #stencilLayer { display: block; z-index: 10; } 

    #emptyState {
      position: absolute; display: flex; flex-direction: column; align-items: center; gap: 16px;
      color: var(--text-sub); pointer-events: none;
    }
    #emptyState span { font-size: 64px; color: var(--outline); }

    /* --- MAGNIFIER --- */
    #magnifier {
      position: fixed; 
      width: 140px; height: 140px; 
      border-radius: 50%;
      border: 3px solid var(--md-sys-color-primary);
      background: #fff;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      overflow: hidden; pointer-events: none; z-index: 9999; display: none; 
    }
    #magCanvas { width: 100%; height: 100%; display: block; }

    /* --- RIGHT PANEL (SIDEBAR) DESKTOP --- */
    #sidebar {
      width: 340px; display: flex; flex-direction: column;
      background: var(--surface-1); border-radius: 16px;
      padding: 20px 16px; gap: 16px; flex-shrink: 0;
      box-shadow: 0 4px 12px var(--shadow-color);
      z-index: 10;
    }

    .brand { 
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      gap: 8px; 
      padding: 0 4px; 
      color: var(--text-main); 
    }

    .brand-main {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .brand-icon { color: var(--md-sys-color-primary); font-size: 28px; flex-shrink: 0; }
    .brand-text { display: flex; flex-direction: column; min-width: 0; }
    .brand-name { font-family: 'Google Sans', sans-serif; font-size: 20px; white-space: nowrap; }
    .brand-pages { font-size: 11px; color: var(--text-sub); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .sidebar-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      width: 48px; 
      height: 48px;
      border-radius: 24px;
      border: none;
      background: transparent;
      color: var(--text-sub);
      cursor: pointer;
    }
    .sidebar-toggle:hover { background: rgba(0,0,0,0.04); }

    .fab-add {
      position: relative; display: flex; align-items: center; justify-content: center; gap: 12px;
      height: 56px; border-radius: 16px; background: var(--md-sys-color-primary-container);
      color: var(--md-sys-color-on-primary-container); font-family: 'Google Sans', sans-serif; font-weight: 500;
      cursor: pointer; transition: 0.2s; overflow: hidden; flex-shrink: 0;
      font-size: 14px;
    }
    .fab-add:hover { filter: brightness(1.08); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    
    #sidebarBody {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.3s var(--ease-slide), transform 0.3s var(--ease-slide);
      will-change: opacity, transform;
    }
    
    #pageList { 
      flex: 1; 
      overflow-y: auto; 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      padding-right: 4px; 
    }
    #pageList::-webkit-scrollbar { width: 4px; }
    #pageList::-webkit-scrollbar-thumb { background: var(--outline); border-radius: 4px; }

    .page-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
      background: transparent;
      user-select: none;
      position: relative;
      will-change: transform;
      transition:
        transform 0.18s var(--ease-spring),
        background 0.18s ease,
        box-shadow 0.18s ease,
        border-color 0.18s ease;
    }
    .page-card:hover { background: rgba(255,255,255,0.05); }
    .page-card.active { 
      background: var(--md-sys-color-primary-container); 
      color: var(--md-sys-color-on-primary-container);
    }
    .page-card.active .page-meta { color: var(--md-sys-color-on-primary-container); opacity: 0.8; }
    .page-card.active .btn-del { color: var(--md-sys-color-on-primary-container); opacity: 0.7; }

    /* --- SORTABLE VISUALS --- */
    .sortable-ghost { opacity: 0 !important; }
    .sortable-drag {
      opacity: 1 !important;
      background: var(--surface-1) !important;
      box-shadow: 0 16px 32px rgba(0,0,0,0.3) !important;
      transform: scale(1.05);
      cursor: grabbing !important;
      z-index: 9999 !important;
      border-color: transparent !important;
      transition: none !important;
    }
    .sortable-chosen { z-index: 1; }

    .thumb {
      width: 48px; height: 64px; border-radius: 6px; background: #eee; object-fit: cover;
      border: 1px solid var(--outline); flex-shrink: 0; pointer-events: none;
    }
    .info { 
      flex: 1; overflow: hidden; display: flex; flex-direction: column; justify-content: center; pointer-events: none;
    }
    .filename { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .page-meta { font-size: 11px; color: var(--text-sub); margin-top: 2px; }
    .drag-handle { color: var(--outline); font-size: 20px; cursor: grab; }

    .btn-del {
      width: 36px; height: 36px; border-radius: 50%; border: none; background: transparent;
      color: var(--text-sub); cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: background 0.15s ease, color 0.15s ease;
    }
    .btn-del:hover { background: rgba(255,0,0,0.1); color: var(--md-sys-color-error); }

    .bottom-controls {
      padding-top: 16px; border-top: 1px solid var(--outline); flex-shrink: 0;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.3s var(--ease-slide), transform 0.3s var(--ease-slide);
      will-change: opacity, transform;
    }
    .btn-main {
      width: 100%; height: 48px; border-radius: 24px; border: none;
      background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary);
      font-family: 'Google Sans', sans-serif; font-weight: 500; cursor: pointer;
      display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s;
    }
    .btn-main:hover { filter: brightness(1.1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
    .btn-main:disabled { background: var(--surface-2); color: var(--outline); cursor: default; box-shadow: none; filter: none; }

    #toast {
      position: fixed; 
      bottom: 32px; 
      left: 50%; 
      transform: translateX(-50%) translateY(20px);
      background: var(--text-main); 
      color: var(--surface-3); 
      padding: 12px 24px; 
      border-radius: 32px;
      font-size: 14px; 
      opacity: 0; 
      transition: 0.3s cubic-bezier(0.2,0,0,1); 
      pointer-events: none; 
      z-index: 100;
      white-space: nowrap;
    }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    /* --- FAB móvil (debajo del desplegable) --- */
    #btnAddMobile {
      position: fixed;
      right: 16px;
      bottom: 24px;
      width: 56px;
      height: 56px;
      border-radius: 16px;
      border: none;
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 60; /* bottom-sheet is 80, will cover it when open */
      transition: transform 0.18s var(--ease-spring), box-shadow 0.18s var(--ease-spring);
    }
    #btnAddMobile span { font-size: 28px; }
    #btnAddMobile:active { transform: scale(0.94); box-shadow: 0 2px 8px rgba(0,0,0,0.25); }

    /* --- MOBILE: bottom-sheet & layout --- */
    @media (max-width: 768px) {
      body { 
        padding: 0; 
        height: 100vh;
      }
      
      #appContainer {
        flex-direction: column;
        padding: 0;
        gap: 0;
        height: 100%;
      }
      
      #mainPanel {
        border-radius: 0;
        flex: 1;
        margin-bottom: 0;
      }

      /* Center preview relative to visible area (top bar + collapsed sheet) */
      #viewport {
        padding-bottom: calc(var(--mobile-sheet-header-height) + 16px);
        box-sizing: border-box;
      }
      
      /* Bottom sheet sidebar */
      #sidebar {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        border-radius: 24px 24px 0 0;
        box-shadow: 0 -8px 24px rgba(0,0,0,0.35);
        
        /* MASSIVE PADDING FIX:
           Changed from 50px to 120px extra space below content.
           This guarantees the button sits well above any Android navigation bar.
        */
        padding: 40px 24px calc(120px + env(safe-area-inset-bottom));
        
        background: var(--surface-1);
        
        /* Fixed height ensures flexbox children behave predictably */
        height: 75vh;
        
        /* Push it down so only header is visible initially */
        transform: translateY(calc(100% - var(--mobile-sheet-header-height)));
        transition: transform 0.35s var(--ease-slide);
        
        display: flex;
        flex-direction: column;
        gap: 24px;
        z-index: 80;
        will-change: transform;
      }

      /* Open state: Slide up */
      #sidebar.open {
        transform: translateY(0);
      }

      /* Hide inner content when closed */
      #sidebar:not(.open) #sidebarBody,
      #sidebar:not(.open) .bottom-controls {
        opacity: 0;
        pointer-events: none;
        transform: translateY(20px);
      }

      /* Show inner content when open */
      #sidebar.open #sidebarBody,
      #sidebar.open .bottom-controls {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      .brand {
        padding: 0;
        cursor: pointer;
        user-select: none;
      }
      .brand-name {
        font-size: 22px;
      }
      .brand-icon {
        font-size: 32px;
      }

      .sidebar-toggle {
        display: flex;
      }

      .fab-add {
        display: none;
      }

      #sidebarBody {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #pageList {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        gap: 8px;
        padding-bottom: 4px;
      }

      .page-card {
        min-width: 0;
        border: 1px solid var(--outline-variant);
      }

      .thumb {
        width: 56px;
        height: 80px;
      }

      #toolbar { padding: 0 8px; height: 56px; }
      .doc-title { width: 160px; font-size: 16px; padding: 4px 8px; }
      .btn-chip { padding: 0 10px; height: 34px; }
      .btn-chip span.label-text { display: none; }

      .hero-title { font-size: 36px; }
      .hero-icon { font-size: 48px; }

      #btnAddMobile {
        display: flex;
        bottom: calc(var(--mobile-sheet-header-height) + env(safe-area-inset-bottom) + 16px);
      }

      #toast { 
        bottom: calc(var(--mobile-sheet-header-height) + env(safe-area-inset-bottom) + 72px); 
      }
      
      .hero-actions {
        flex-direction: column;
        width: 100%;
      }
      .btn-hero {
        width: 100%;
        justify-content: center;
      }
    }

    @media (min-width: 769px) {
      .sidebar-toggle {
        display: none;
      }
    }
  </style>
</head>
<body>

  <div id="appLoading">
    <div class="spinner"></div>
    <span style="font-family:'Google Sans'; font-size:18px; color:var(--text-main);">Loading Core...</span>
  </div>

  <div id="landingPage">
    <div class="hero-content">
      <span class="material-symbols-rounded hero-icon">document_scanner</span>
      <h1 class="hero-title">Scanner</h1>
      <p class="hero-sub">Digitize, Crop & Export</p>
      
      <div class="hero-actions">
        <!-- Botón Original New Scan -->
        <button class="btn-hero" id="btnLandingStart">
          <span class="material-symbols-rounded">add</span>
          New Scan
        </button>

        <!-- Nuevo Botón Dropdown Stencil -->
        <div class="dropdown" id="stencilDropdown">
          <button class="btn-hero secondary" id="btnStencilToggle">
            <span class="material-symbols-rounded">download</span>
            Download Stencil
          </button>
          <div class="dropdown-content">
            <button class="dropdown-item" onclick="downloadStencil('pdf')">
              <span class="material-symbols-rounded">picture_as_pdf</span>
              PDF Document
            </button>
            <button class="dropdown-item" onclick="downloadStencil('svg')">
              <span class="material-symbols-rounded">gesture</span>
              SVG Vector
            </button>
            <button class="dropdown-item" onclick="downloadStencil('png')">
              <span class="material-symbols-rounded">image</span>
              PNG Image
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="modalOverlay">
    <div class="modal-card">
      <h2 class="modal-title">New Scan</h2>
      <div class="input-group">
        <input type="text" id="scanNameInput" class="mat-input" placeholder="Untitled Scan" autofocus>
        <span class="input-label">Document Name</span>
      </div>
      <div class="modal-actions">
        <button class="btn-text" id="btnModalCancel">Cancel</button>
        <button class="btn-fill" id="btnModalCreate">Create</button>
      </div>
    </div>
  </div>

  <div id="appContainer" class="hidden">
    
    <div id="magnifier">
      <canvas id="magCanvas"></canvas>
    </div>

    <input type="file" id="fileInput" accept="image/*" multiple hidden disabled>

    <div id="mainPanel">
      <div id="toolbar">
        <input type="text" class="doc-title" id="docTitle" value="Untitled Document">
        <div class="actions">
          <button class="btn-icon" id="themeBtn" title="Theme">
            <span class="material-symbols-rounded">dark_mode</span>
          </button>
          <div style="width:1px; height:20px; background:var(--outline); opacity:0.3;"></div>
          
          <button class="btn-chip" id="autoCropBtn" style="display:none">
            <span class="material-symbols-rounded">auto_fix</span> <span class="label-text">Auto</span>
          </button>

          <button class="btn-chip" id="cropBtn" disabled>
            <span class="material-symbols-rounded">crop</span> <span class="label-text">Crop</span>
          </button>

          <button class="btn-chip" id="stencilBtn" disabled>
            <span class="material-symbols-rounded">grid_4x4</span> <span class="label-text">Ref</span>
          </button>
        </div>
      </div>

      <div id="viewport">
        <div id="emptyState">
          <span class="material-symbols-rounded">add_photo_alternate</span>
          <p>Add photos to start</p>
        </div>

        <div id="paper">
          <img id="previewImg" alt="Scan">
          <canvas id="stencilLayer" class="layer-canvas"></canvas>
          <canvas id="cropLayer" class="layer-canvas"></canvas>
        </div>
      </div>
      
      <div id="toast">Notification</div>
    </div>

    <!-- FAB flotante sólo móvil (bajo el desplegable) -->
    <button id="btnAddMobile" aria-label="Add pages">
      <span class="material-symbols-rounded">add</span>
    </button>

    <div id="sidebar">
      <!-- Brand section acts as click target to open sidebar on mobile -->
      <div class="brand" id="mobileSidebarHeader">
        <div class="brand-main">
          <span class="material-symbols-rounded brand-icon">document_scanner</span>
          <div class="brand-text">
            <span class="brand-name">Scanner</span>
            <span class="brand-pages" id="pageSummary">No pages</span>
          </div>
        </div>
        <button id="sidebarToggle" class="sidebar-toggle" aria-expanded="false">
          <span id="sidebarToggleIcon" class="material-symbols-rounded">expand_less</span>
        </button>
      </div>

      <div class="fab-add" id="btnDesktopAdd">
        <span class="material-symbols-rounded">add</span> Add Pages
      </div>

      <div id="sidebarBody">
        <div id="pageList"></div>
      </div>

      <div class="bottom-controls">
        <button id="exportBtn" class="btn-main" disabled>
          <span class="material-symbols-rounded">picture_as_pdf</span> Export PDF
        </button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <script>
    const STATE = {
      pages: [], 
      currentIdx: -1,
      isCropMode: false,
      isStencilMode: true,
      cvReady: false,
      theme: 'dark' 
    };

    const A4_W = 2480, A4_H = 3508; 
    const WHITE_THRESHOLD = 87;
    const PX_PER_CM = 118.09;
    
    const STENCIL_CFG = {
        w: 18 * PX_PER_CM,
        h: 27 * PX_PER_CM,
        x: 1.5 * PX_PER_CM,
        y: 1.43 * PX_PER_CM,
        borderColor: '#ffde00',
        bgColor: '#ffffff',
        gapMM: 0.4 
    };

    const MARKER_TARGET = {
        x: 10.375 * PX_PER_CM,
        y: 27.675 * PX_PER_CM
    };

    const colorKeys = ['red','blue','green','black','white'];
    const calibration = {
      red:{src:null,dst:[255,0,0]}, blue:{src:null,dst:[90,90,180]},
      green:{src:null,dst:[180,255,0]}, black:{src:null,dst:[0,0,0]},
      white:{src:null,dst:[255,255,255]}
    };
    const windowAnchors = {
      red:[100,50,50], blue:[30,40,70], green:[90,110,50],
      black:[0,0,0], white:[255,255,255]
    };
    const defaultColorWindow = { x1:1105, y1:3200, x2:1370, y2:3370 };

    const $ = id => document.getElementById(id);
    const els = {
      landing: $('landingPage'),
      modal: $('modalOverlay'),
      app: $('appContainer'),
      nameInput: $('scanNameInput'),
      paper: $('paper'),
      img: $('previewImg'),
      canvas: $('cropLayer'),
      stencil: $('stencilLayer'),
      viewport: $('viewport'),
      empty: $('emptyState'),
      list: $('pageList'),
      fileIn: $('fileInput'),
      loading: $('appLoading'),
      magnifier: $('magnifier'),
      magCanvas: $('magCanvas'),
      sidebar: $('sidebar'),
      pageSummary: $('pageSummary'),
      sidebarToggle: $('sidebarToggle'),
      sidebarToggleIcon: $('sidebarToggleIcon'),
      btnDesktopAdd: $('btnDesktopAdd'),
      btnAddMobile: $('btnAddMobile'),
      mobileSidebarHeader: $('mobileSidebarHeader'),
      stencilDropdown: $('stencilDropdown'),
      btnStencilToggle: $('btnStencilToggle')
    };
    const ctx = els.canvas.getContext('2d');
    const stx = els.stencil.getContext('2d');
    const magCtx = els.magCanvas.getContext('2d');

    /* --- DROPDOWN LOGIC --- */
    els.btnStencilToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        els.stencilDropdown.classList.toggle('show');
    });

    window.addEventListener('click', (e) => {
        if (!e.target.closest('#stencilDropdown')) {
            els.stencilDropdown.classList.remove('show');
        }
    });

    /* --- STENCIL GENERATION (Matches SVG Design) --- */
    function getStencilSVGString() {
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 29.7" width="21cm" height="29.7cm">
            <defs>
                <filter id="softBlur" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0.02" />
                </filter>
                <pattern id="dotGrid" x="1.75" y="1.68" width="0.5" height="0.5" patternUnits="userSpaceOnUse">
                    <circle cx="0.25" cy="0.25" r="0.035" fill="#a8a8a8" filter="url(#softBlur)" />
                </pattern>
            </defs>
            <!-- A4 Background -->
            <rect x="0" y="0" width="21" height="29.7" fill="white" />
            <!-- Main Yellow Frame -->
            <rect x="1.5" y="1.43" width="18" height="27" rx="0.03" ry="0.03" fill="none" stroke="#ffde00" stroke-width="0.06" />
            <!-- Dot Grid Area -->
            <rect x="1.75" y="1.68" width="17.5" height="25.5" fill="url(#dotGrid)" />
            <!-- Footer -->
            <g stroke="#ffde00" stroke-width="0.06" fill="none">
                <rect x="2.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 2.5 27.43 v 0.5 M 3.0 27.43 v 0.5 M 3.5 27.43 v 0.5 M 4.0 27.43 v 0.5 M 4.5 27.43 v 0.5 M 5.0 27.43 v 0.5 M 5.5 27.43 v 0.5 M 6.0 27.43 v 0.5 M 6.5 27.43 v 0.5 M 7.0 27.43 v 0.5 M 7.5 27.43 v 0.5 M 8.0 27.43 v 0.5 M 8.5 27.43 v 0.5 M 9.0 27.43 v 0.5 M 9.5 27.43 v 0.5" />
                <rect x="11.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 11.5 27.43 v 0.5 M 12.0 27.43 v 0.5 M 12.5 27.43 v 0.5 M 13.0 27.43 v 0.5 M 13.5 27.43 v 0.5 M 14.0 27.43 v 0.5 M 14.5 27.43 v 0.5 M 15.0 27.43 v 0.5 M 15.5 27.43 v 0.5 M 16.0 27.43 v 0.5 M 16.5 27.43 v 0.5 M 17.0 27.43 v 0.5 M 17.5 27.43 v 0.5 M 18.0 27.43 v 0.5 M 18.5 27.43 v 0.5" />
            </g>
            <!-- Footer Colors -->
            <g stroke="#ffde00" stroke-width="0.06">
                <circle cx="10.125" cy="27.68" r="0.125" fill="#ff0000" />
                <circle cx="10.375" cy="27.68" r="0.125" fill="#000000" />
                <circle cx="10.625" cy="27.68" r="0.125" fill="#0000ff" />
                <circle cx="10.875" cy="27.68" r="0.125" fill="#6eff12" />
            </g>
        </svg>`;
    }

    function downloadStencil(type) {
        const svgString = getStencilSVGString();
        
        if (type === 'svg') {
            const blob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "scanner_stencil.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            // Convert to Canvas for PNG/PDF
            const img = new Image();
            const svgBlob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(svgBlob);
            
            img.onload = function() {
                // High Res A4 Canvas (approx 300 DPI)
                const canvas = document.createElement("canvas");
                canvas.width = 2480;
                canvas.height = 3508;
                const ctx = canvas.getContext("2d");
                
                // Draw white background
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Draw SVG
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(url);

                if (type === 'png') {
                    const link = document.createElement("a");
                    link.download = "scanner_stencil.png";
                    link.href = canvas.toDataURL("image/png");
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else if (type === 'pdf') {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });
                    const imgData = canvas.toDataURL('image/jpeg', 0.95);
                    pdf.addImage(imgData, 'JPEG', 0, 0, 210, 297);
                    pdf.save("scanner_stencil.pdf");
                }
            };
            img.src = url;
        }
        els.stencilDropdown.classList.remove('show');
    }

    /* --- ZOOM STATE FOR PREVIEW (pinch on mobile) --- */
    const zoomState = {
      scale: 1,
      min: 1,
      max: 3,
      offsetX: 0,
      offsetY: 0
    };
    let pinchStartDistance = 0;
    let pinchStartScale = 1;
    let panStartX = 0;
    let panStartY = 0;
    let isPanning = false;

    function resetZoom() {
      zoomState.scale = 1;
      zoomState.offsetX = 0;
      zoomState.offsetY = 0;
      applyZoomTransform();
    }

    function applyZoomTransform() {
      els.paper.style.transform = `translate(${zoomState.offsetX}px, ${zoomState.offsetY}px) scale(${zoomState.scale})`;
    }

    function getDistance(t1, t2) {
      const dx = t1.clientX - t2.clientX;
      const dy = t1.clientY - t2.clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function handleZoomStart(e) {
      if (STATE.isCropMode || STATE.currentIdx < 0) return;
      if (e.touches.length === 2) {
        e.preventDefault();
        pinchStartDistance = getDistance(e.touches[0], e.touches[1]);
        pinchStartScale = zoomState.scale;
        isPanning = false;
      } else if (e.touches.length === 1 && zoomState.scale > 1) {
        e.preventDefault();
        isPanning = true;
        panStartX = e.touches[0].clientX - zoomState.offsetX;
        panStartY = e.touches[0].clientY - zoomState.offsetY;
      }
    }

    function handleZoomMove(e) {
      if (STATE.isCropMode || STATE.currentIdx < 0) return;
      if (e.touches.length === 2 && pinchStartDistance > 0) {
        e.preventDefault();
        const newDist = getDistance(e.touches[0], e.touches[1]);
        let newScale = pinchStartScale * (newDist / pinchStartDistance);
        if (newScale < zoomState.min) newScale = zoomState.min;
        if (newScale > zoomState.max) newScale = zoomState.max;
        zoomState.scale = newScale;
        applyZoomTransform();
      } else if (e.touches.length === 1 && isPanning && zoomState.scale > 1) {
        e.preventDefault();
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        zoomState.offsetX = x - panStartX;
        zoomState.offsetY = y - panStartY;
        applyZoomTransform();
      }
    }

    function handleZoomEnd(e) {
      if (e.touches.length < 2) {
        pinchStartDistance = 0;
      }
      if (e.touches.length === 0) {
        isPanning = false;
      }
      if (zoomState.scale <= 1.01) {
        zoomState.scale = 1;
        zoomState.offsetX = 0;
        zoomState.offsetY = 0;
        applyZoomTransform();
      }
    }

    els.viewport.addEventListener('touchstart', handleZoomStart, {passive:false});
    els.viewport.addEventListener('touchmove', handleZoomMove, {passive:false});
    els.viewport.addEventListener('touchend', handleZoomEnd);
    els.viewport.addEventListener('touchcancel', handleZoomEnd);

    /* --- SORTABLE SETUP --- */
    let sortable = null;

    function setupSortable() {
      if (!els.list) return;
      if (sortable) sortable.destroy();
      sortable = new Sortable(els.list, {
        animation: 220,
        easing: 'cubic-bezier(0.2,0,0,1)',
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',
        handle: '.drag-handle',
        direction: 'vertical',
        swapThreshold: 0.5,
        forceFallback: true,        // ensure visible drag clone everywhere
        fallbackOnBody: true,
        fallbackTolerance: 3,
        onEnd: (evt) => {
          const item = STATE.pages.splice(evt.oldIndex, 1)[0];
          STATE.pages.splice(evt.newIndex, 0, item);
          if(STATE.currentIdx === evt.oldIndex) STATE.currentIdx = evt.newIndex;
          else if(STATE.currentIdx > evt.oldIndex && STATE.currentIdx <= evt.newIndex) STATE.currentIdx--;
          else if(STATE.currentIdx < evt.oldIndex && STATE.currentIdx >= evt.newIndex) STATE.currentIdx++;
          renderList();
        }
      });
    }

    window.addEventListener('resize', () => {
      if (STATE.cvReady && STATE.currentIdx >= 0) {
        updateViewGeometry();
      }
    });

    // --- INITIALIZATION ---
    var Module = {
      onRuntimeInitialized: function() {
        STATE.cvReady = true;
        els.loading.style.opacity = '0';
        setTimeout(() => els.loading.remove(), 400);
        els.fileIn.disabled = false;
        
        const sysDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setTheme(localStorage.getItem('theme') || (sysDark ? 'dark' : 'light'));
        
        setupSortable();

        new ResizeObserver(() => {
          if(STATE.currentIdx >= 0) updateViewGeometry();
        }).observe(els.viewport);
      }
    };

    /* --- SIDEBAR TOGGLE (mobile bottom sheet) --- */
    function toggleSidebar() {
      const isOpen = els.sidebar.classList.toggle('open');
      els.sidebarToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      els.sidebarToggleIcon.textContent = isOpen ? 'expand_more' : 'expand_less';
    }

    // Allow clicking the arrow button...
    els.sidebarToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleSidebar();
    });

    // ...AND allow clicking the entire header bar on mobile to unhide it easily
    els.mobileSidebarHeader.addEventListener('click', () => {
      if(window.innerWidth <= 768) {
        toggleSidebar();
      }
    });

    /* --- NAVIGATION / APP FLOW --- */
    
    $('btnLandingStart').onclick = () => {
      els.modal.classList.add('open');
      els.nameInput.value = '';
      els.nameInput.focus();
    };

    $('btnModalCancel').onclick = () => {
      els.modal.classList.remove('open');
    };

    $('btnModalCreate').onclick = enterMainApp;
    els.nameInput.addEventListener('keypress', (e) => {
      if(e.key === 'Enter') enterMainApp();
    });

    function enterMainApp() {
      const name = els.nameInput.value.trim() || "Untitled Scan";
      $('docTitle').value = name;
      els.modal.classList.remove('open');
      els.landing.style.opacity = '0';
      els.landing.style.transform = 'scale(1.1)';
      els.landing.style.pointerEvents = 'none';
      els.app.classList.remove('hidden');
      setTimeout(() => { els.app.classList.add('active'); }, 50);
    }

    /* --- FILE INPUT HANDLING --- */
    const triggerFile = () => els.fileIn.click();
    els.btnDesktopAdd.onclick = triggerFile;
    els.btnAddMobile.onclick = triggerFile;
    els.fileIn.onchange = e => handleFiles(e.target.files);


    /* --- LOGIC --- */

    async function handleFiles(files) {
      if(!STATE.cvReady || !files.length) return;
      els.empty.style.display = 'none';
      showToast('Processing...');

      for(const file of files) {
        const img = await loadImage(file);
        const c = document.createElement('canvas');
        c.width = img.naturalWidth; c.height = img.naturalHeight;
        c.getContext('2d').drawImage(img,0,0);
        
        const pageQuad = detectCorners(c);
        const warpResult = smartWarp(c, pageQuad);
        let alignedCanvas = warpResult.canvas;
        const usedYellow = warpResult.usedYellow;
        const scanResult = scanForColors(alignedCanvas);
        let markerCenter = null;

        if(!usedYellow && scanResult.found && scanResult.blackPt) {
             const rawCenter = findBlackBlobCentroid(alignedCanvas, scanResult.blackPt);
             alignedCanvas = alignToMarker(alignedCanvas, rawCenter);
             markerCenter = { x: MARKER_TARGET.x, y: MARKER_TARGET.y };
        } else if (usedYellow) {
             markerCenter = { x: MARKER_TARGET.x, y: MARKER_TARGET.y };
        }

        const T = buildColorTransform();
        const processed = (T) ? applyRecolor(alignedCanvas, T) : alignedCanvas;
        
        const displayUrl = await canvasToUrl(processed);
        const thumbUrl = await canvasToUrl(resizeCanvas(processed, 100));

        STATE.pages.push({
          id: Date.now() + Math.random(),
          src: c,
          processed: processed,
          displayUrl: displayUrl,
          thumbUrl: thumbUrl,
          quad: pageQuad,
          name: file.name,
          marker: markerCenter,
          yellowUsed: usedYellow
        });
      }

      renderList();
      selectPage(STATE.pages.length - 1);
      $('exportBtn').disabled = false;
    }

    function smartWarp(srcCanvas, pageQuad) {
        const yellowQuad = detectYellowRect(srcCanvas);
        if (yellowQuad) {
            const dstStencil = [
                STENCIL_CFG.x, STENCIL_CFG.y, 
                STENCIL_CFG.x + STENCIL_CFG.w, STENCIL_CFG.y,
                STENCIL_CFG.x + STENCIL_CFG.w, STENCIL_CFG.y + STENCIL_CFG.h,
                STENCIL_CFG.x, STENCIL_CFG.y + STENCIL_CFG.h
            ];
            return { canvas: warpGeneral(srcCanvas, yellowQuad, dstStencil), usedYellow: true };
        } else {
            const dstA4 = [0,0, A4_W,0, A4_W,A4_H, 0,A4_H];
            return { canvas: warpGeneral(srcCanvas, pageQuad, dstA4), usedYellow: false };
        }
    }

    function detectYellowRect(srcCanvas) {
        let src = cv.imread(srcCanvas);
        let srcRGB = new cv.Mat();
        cv.cvtColor(src, srcRGB, cv.COLOR_RGBA2RGB); 
        let hsv = new cv.Mat();
        cv.cvtColor(srcRGB, hsv, cv.COLOR_RGB2HSV);
        
        let mask = new cv.Mat();
        let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [15, 60, 60, 0]);
        let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [40, 255, 255, 255]);
        
        cv.inRange(hsv, low, high, mask);
        let M = new cv.Mat();
        let kernel = cv.Mat.ones(5, 5, cv.CV_8U);
        cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);

        let contours = new cv.MatVector();
        cv.findContours(mask, contours, M, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        let best = null;
        let maxArea = 0;
        const minArea = (src.cols * src.rows) * 0.05;

        for(let i=0; i<contours.size(); i++) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if(area > maxArea && area > minArea) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.04 * peri, true);
                if(approx.rows === 4 && cv.isContourConvex(approx)) {
                    maxArea = area;
                    best = [];
                    for(let j=0; j<4; j++) {
                        best.push({x: approx.intPtr(j)[0], y: approx.intPtr(j)[1]});
                    }
                }
                approx.delete();
            }
        }
        src.delete(); srcRGB.delete(); hsv.delete(); mask.delete(); kernel.delete(); contours.delete(); M.delete();
        return best ? orderQuad(best) : null;
    }

    function warpGeneral(srcCanvas, srcQuad, dstCoordsArray) {
        let src = cv.imread(srcCanvas);
        let dst = new cv.Mat();
        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, srcQuad.flatMap(q=>[q.x,q.y]));
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, dstCoordsArray);
        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        cv.warpPerspective(src, dst, M, new cv.Size(A4_W, A4_H), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));
        let out = document.createElement('canvas');
        out.width = A4_W; out.height = A4_H;
        cv.imshow(out, dst);
        src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
        return out;
    }

    function selectPage(idx) {
      if(idx < 0 || idx >= STATE.pages.length) return;
      if(STATE.isCropMode) toggleCropMode();
      STATE.currentIdx = idx;
      renderList();
      const p = STATE.pages[idx];
      els.paper.style.display = 'block';
      els.img.src = p.displayUrl;
      els.img.style.display = 'block';
      els.canvas.style.display = 'none';
      $('cropBtn').disabled = false;
      $('stencilBtn').disabled = false;
      if(STATE.isStencilMode) $('stencilBtn').classList.add('active');
      else $('stencilBtn').classList.remove('active');
      drawOverlay(stx, p.processed.width, p.processed.height);
      updateViewGeometry();
      resetZoom();
    }

    function updateViewGeometry() {
      if(STATE.currentIdx < 0) return;
      const p = STATE.pages[STATE.currentIdx];
      const sourceW = STATE.isCropMode ? p.src.width : p.processed.width;
      const sourceH = STATE.isCropMode ? p.src.height : p.processed.height;
      const aspect = sourceW / sourceH;
      const pad = 40;
      const availW = els.viewport.clientWidth - pad;
      const availH = els.viewport.clientHeight - pad;
      if(availW <= 0) return;
      let finalW = availW;
      let finalH = availW / aspect;
      if(finalH > availH) {
        finalH = availH;
        finalW = availH * aspect;
      }
      els.paper.style.width = `${finalW}px`;
      els.paper.style.height = `${finalH}px`;
      if(STATE.isCropMode) drawCropCanvas();
      if(!STATE.isCropMode) drawOverlay(stx, p.processed.width, p.processed.height);
      resetZoom();
    }

    function toggleCropMode() {
      if(STATE.currentIdx < 0) return;
      STATE.isCropMode = !STATE.isCropMode;
      const btn = $('cropBtn');
      const autoBtn = $('autoCropBtn');
      const stencilBtn = $('stencilBtn');
      const p = STATE.pages[STATE.currentIdx];

      if(STATE.isCropMode) {
        btn.innerHTML = '<span class="material-symbols-rounded">check</span> <span class="label-text">Done</span>';
        btn.classList.add('active');
        autoBtn.style.display = 'flex';
        stencilBtn.style.display = 'none'; 
        els.img.style.display = 'none';
        els.stencil.style.display = 'none'; 
        els.canvas.style.display = 'block';
        els.canvas.width = p.src.width;
        els.canvas.height = p.src.height;
        drawCropCanvas();
      } else {
        btn.innerHTML = '<span class="material-symbols-rounded">crop</span> <span class="label-text">Crop</span>';
        btn.classList.remove('active');
        autoBtn.style.display = 'none';
        stencilBtn.style.display = 'flex';
        els.stencil.style.display = 'block';
        showToast('Applying...');
        setTimeout(async () => {
          const dstA4 = [0,0, A4_W,0, A4_W,A4_H, 0,A4_H];
          let intermediateCanvas = warpGeneral(p.src, p.quad, dstA4);
          const yellowQuad = detectYellowRect(intermediateCanvas);
          let alignedCanvas = intermediateCanvas;
          let usedYellow = false;
          if (yellowQuad) {
             const dstStencil = [
                STENCIL_CFG.x, STENCIL_CFG.y, 
                STENCIL_CFG.x + STENCIL_CFG.w, STENCIL_CFG.y,
                STENCIL_CFG.x + STENCIL_CFG.w, STENCIL_CFG.y + STENCIL_CFG.h,
                STENCIL_CFG.x, STENCIL_CFG.y + STENCIL_CFG.h
             ];
             alignedCanvas = warpGeneral(intermediateCanvas, yellowQuad, dstStencil);
             usedYellow = true;
          }
          const scanResult = scanForColors(alignedCanvas);
          if(!usedYellow && scanResult.found && scanResult.blackPt) {
               const rawCenter = findBlackBlobCentroid(alignedCanvas, scanResult.blackPt);
               alignedCanvas = alignToMarker(alignedCanvas, rawCenter);
               p.marker = { x: MARKER_TARGET.x, y: MARKER_TARGET.y };
          } else {
               p.marker = usedYellow ? { x: MARKER_TARGET.x, y: MARKER_TARGET.y } : null;
          }
          const T = buildColorTransform();
          const processed = (T) ? applyRecolor(alignedCanvas, T) : alignedCanvas;
          p.processed = processed;
          p.displayUrl = await canvasToUrl(processed);
          p.thumbUrl = await canvasToUrl(resizeCanvas(processed, 100));
          p.yellowUsed = usedYellow; 
          selectPage(STATE.currentIdx);
          renderList();
        }, 10);
      }
      updateViewGeometry();
    }

    function toggleStencilMode() {
        if(STATE.currentIdx < 0 || STATE.isCropMode) return;
        STATE.isStencilMode = !STATE.isStencilMode;
        const btn = $('stencilBtn');
        const p = STATE.pages[STATE.currentIdx];
        if(STATE.isStencilMode) btn.classList.add('active');
        else btn.classList.remove('active');
        drawOverlay(stx, p.processed.width, p.processed.height);
    }

    function alignToMarker(srcCanvas, currentXY) {
        const targetX = MARKER_TARGET.x;
        const targetY = MARKER_TARGET.y;
        const diffX = targetX - currentXY.x;
        const diffY = targetY - currentXY.y;
        const out = document.createElement('canvas');
        out.width = A4_W;
        out.height = A4_H;
        const cCtx = out.getContext('2d');
        cCtx.fillStyle = '#ffffff';
        cCtx.fillRect(0, 0, A4_W, A4_H);
        cCtx.drawImage(srcCanvas, diffX, diffY);
        return out;
    }

    function drawOverlay(targetCtx, w, h, isExport = false) {
        if (isExport) {
            const overlay = document.createElement('canvas');
            overlay.width = w;
            overlay.height = h;
            const oCtx = overlay.getContext('2d');
            _renderOverlayContent(oCtx, w, h);
            targetCtx.drawImage(overlay, 0, 0);
            return;
        }
        if(targetCtx.canvas === els.stencil) {
            els.stencil.width = w;
            els.stencil.height = h;
        }
        targetCtx.clearRect(0, 0, w, h);
        _renderOverlayContent(targetCtx, w, h);
    }

    function _renderOverlayContent(ctx, w, h) {
        const scaleX = w / A4_W;
        const scaleY = h / A4_H;
        if (STATE.isStencilMode) {
            const sX = STENCIL_CFG.x * scaleX;
            const sY = STENCIL_CFG.y * scaleY;
            const sW = STENCIL_CFG.w * scaleX;
            const sH = STENCIL_CFG.h * scaleY;
            const lineWidth = 8 * scaleX; 
            const gapPx = (STENCIL_CFG.gapMM / 10) * PX_PER_CM * scaleX;
            const holeOffset = (lineWidth / 2) + gapPx;
            ctx.fillStyle = STENCIL_CFG.bgColor;
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillRect(sX + holeOffset, sY + holeOffset, sW - (holeOffset * 2), sH - (holeOffset * 2));
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = STENCIL_CFG.borderColor;
            ctx.lineWidth = lineWidth; 
            ctx.strokeRect(sX, sY, sW, sH);
        }
    }

    function scanForColors(warpedCanvas) {
      const cCtx = warpedCanvas.getContext('2d');
      const {x1,y1,x2,y2} = defaultColorWindow;
      const w=x2-x1, h=y2-y1;
      if(w <= 0 || h <= 0) return { found: false, blackPt: null };
      const data = cCtx.getImageData(x1,y1,w,h).data;
      const nearest = {};
      colorKeys.forEach(k => nearest[k]={dist:Infinity, rgb:null, xy:null});
      for(let i=0; i<data.length; i+=12) { 
        const r=data[i], g=data[i+1], b=data[i+2];
        const lx = (i/4) % w;
        const ly = Math.floor((i/4) / w);
        const gx = x1 + lx;
        const gy = y1 + ly;
        colorKeys.forEach(k => {
          const ideal = windowAnchors[k];
          const dist = (r-ideal[0])**2 + (g-ideal[1])**2 + (b-ideal[2])**2;
          if(dist < nearest[k].dist) {
             nearest[k] = {dist, rgb:[r,g,b], xy: {x: gx, y: gy}};
          }
        });
      }
      let cnt=0;
      colorKeys.forEach(k => { if(nearest[k].rgb){ calibration[k].src=nearest[k].rgb; cnt++; } });
      return { found: cnt===5, blackPt: nearest['black'] ? nearest['black'].xy : null };
    }

    function findBlackBlobCentroid(canvas, seed) {
        const cCtx = canvas.getContext('2d');
        const {x1,y1,x2,y2} = defaultColorWindow;
        const w = x2 - x1;
        const h = y2 - y1;
        const imageData = cCtx.getImageData(x1, y1, w, h);
        const data = imageData.data;
        const startX = Math.round(seed.x - x1);
        const startY = Math.round(seed.y - y1);
        if(startX < 0 || startX >= w || startY < 0 || startY >= h) return seed;
        const stack = [[startX, startY]];
        const visited = new Uint8Array(w * h); 
        const IS_BLACK = (idx) => (data[idx] + data[idx+1] + data[idx+2]) < 150;
        const startIdx = (startY * w + startX);
        visited[startIdx] = 1;
        let sumX = 0, sumY = 0, count = 0;
        while(stack.length > 0) {
           const [cx, cy] = stack.pop();
           sumX += cx; sumY += cy; count++;
           const neighbors = [[cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]];
           for(let i=0; i<neighbors.length; i++) {
             const nx = neighbors[i][0];
             const ny = neighbors[i][1];
             if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
               const nIdx = (ny * w + nx);
               if(visited[nIdx] === 0) {
                 if(IS_BLACK(nIdx * 4)) {
                   visited[nIdx] = 1;
                   stack.push([nx, ny]);
                 }
               }
             }
           }
        }
        if(count === 0) return seed;
        return { x: (sumX / count) + x1, y: (sumY / count) + y1 };
    }

    function autoCrop() {
      if(STATE.currentIdx < 0) return;
      showToast('Detecting...');
      setTimeout(async () => {
        const p = STATE.pages[STATE.currentIdx];
        const newQuad = detectCorners(p.src);
        if(newQuad) {
          p.quad = newQuad;
          drawCropCanvas();
        }
      }, 10);
    }

    function drawCropCanvas() {
      const p = STATE.pages[STATE.currentIdx];
      const w = els.canvas.width;
      const h = els.canvas.height;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(p.src, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.rect(0, 0, w, h);
      p.quad.forEach((pt,i) => {
          if(i===0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
      });
      ctx.closePath();
      ctx.fill('evenodd');
      const styles = getComputedStyle(document.body);
      const colPrim = styles.getPropertyValue('--md-sys-color-primary').trim();
      const colCont = styles.getPropertyValue('--md-sys-color-primary-container').trim();
      ctx.strokeStyle = colPrim;
      ctx.lineWidth = Math.max(2, w/300);
      ctx.beginPath();
      p.quad.forEach((pt,i) => i===0 ? ctx.moveTo(pt.x,pt.y) : ctx.lineTo(pt.x,pt.y));
      ctx.closePath();
      ctx.stroke();
      const rad = Math.max(5, w/80);
      p.quad.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, rad*2, 0, Math.PI*2);
        ctx.fillStyle = colCont;
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, rad/2, 0, Math.PI*2);
        ctx.fillStyle = colPrim;
        ctx.fill();
      });
    }

    function updateMagnifier(x, y) {
      const p = STATE.pages[STATE.currentIdx];
      const zoom = 2;
      const size = 140;
      els.magCanvas.width = size;
      els.magCanvas.height = size;
      magCtx.clearRect(0,0,size,size);
      magCtx.drawImage(p.src, x - (size/2)/zoom, y - (size/2)/zoom, size/zoom, size/zoom, 0, 0, size, size);
      const styles = getComputedStyle(document.body);
      const colPrim = styles.getPropertyValue('--md-sys-color-primary').trim();
      magCtx.beginPath();
      magCtx.moveTo(size/2, 0); magCtx.lineTo(size/2, size);
      magCtx.moveTo(0, size/2); magCtx.lineTo(size, size/2);
      magCtx.strokeStyle = colPrim;
      magCtx.lineWidth = 2;
      magCtx.stroke();
      const rect = els.canvas.getBoundingClientRect();
      const scaleX = rect.width / els.canvas.width;
      const scaleY = rect.height / els.canvas.height;
      const screenX = rect.left + (x * scaleX);
      const screenY = rect.top + (y * scaleY);
      
      const isMobile = window.innerWidth <= 768;
      const yOffset = (screenY < 150) ? 80 : (isMobile ? -140 : -90);
      
      els.magnifier.style.display = 'block';
      els.magnifier.style.left = `${screenX}px`;
      els.magnifier.style.top = `${screenY + yOffset}px`;
      els.magnifier.style.transform = 'translate(-50%, -50%)';
    }

    function detectCorners(srcCanvas) {
      let src = cv.imread(srcCanvas);
      let ds = new cv.Mat();
      const scale = Math.min(1, 800/Math.max(src.cols, src.rows));
      cv.resize(src, ds, new cv.Size(), scale, scale);
      let gray = new cv.Mat();
      cv.cvtColor(ds, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      cv.Canny(gray, gray, 50, 150);
      let contours = new cv.MatVector();
      cv.findContours(gray, contours, new cv.Mat(), cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0; i<contours.size(); i++) {
        let cnt = contours.get(i);
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4 && cv.isContourConvex(approx)) {
          let area = cv.contourArea(approx);
          if(area > maxA && area > (ds.cols*ds.rows*0.1)) {
            maxA = area;
            best = [];
            for(let j=0;j<4;j++) best.push({x: approx.intPtr(j)[0]/scale, y: approx.intPtr(j)[1]/scale});
          }
        }
        approx.delete();
      }
      src.delete(); ds.delete(); gray.delete(); contours.delete();
      if(!best) return [{x:0,y:0}, {x:srcCanvas.width,y:0}, {x:srcCanvas.width,y:srcCanvas.height}, {x:0,y:srcCanvas.height}];
      return orderQuad(best);
    }

    function orderQuad(pts) {
      const s = pts.map(p => p.x + p.y);
      const d = pts.map(p => p.x - p.y);
      return [
        pts[s.indexOf(Math.min(...s))], 
        pts[d.indexOf(Math.max(...d))],
        pts[s.indexOf(Math.max(...s))], 
        pts[d.indexOf(Math.min(...d))]
      ];
    }

    function solve4x4(G,b){
      const M=[[...G[0],b[0]],[...G[1],b[1]],[...G[2],b[2]],[...G[3],b[3]]];
      for(let col=0;col<4;col++){
        let piv=col;
        for(let r=col+1;r<4;r++) if(Math.abs(M[r][col])>Math.abs(M[piv][col])) piv=r;
        if(Math.abs(M[piv][col])<1e-8) return null;
        if(piv!==col){ const tmp=M[piv];M[piv]=M[col];M[col]=tmp; }
        const pv=M[col][col];
        for(let j=col;j<5;j++) M[col][j]/=pv;
        for(let r=0;r<4;r++) if(r!==col){
          const f=M[r][col];
          for(let j=col;j<5;j++) M[r][j]-=f*M[col][j];
        }
      }
      return [M[0][4],M[1][4],M[2][4],M[3][4]];
    }

    function buildColorTransform(){
      for(const k of colorKeys) if(!calibration[k].src) return null;
      const S=[], Tr=[], Tg=[], Tb=[];
      colorKeys.forEach(k=>{
        const s=calibration[k].src, d=calibration[k].dst;
        S.push([s[0],s[1],s[2],1]);
        Tr.push(d[0]); Tg.push(d[1]); Tb.push(d[2]);
      });
      const G=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
      for(let i=0;i<5;i++){
        const s=S[i];
        for(let r=0;r<4;r++) for(let c=0;c<4;c++) G[r][c]+=s[r]*s[c];
      }
      const makeB = (T) => {
        const b=[0,0,0,0];
        for(let i=0;i<5;i++) for(let r=0;r<4;r++) b[r]+=S[i][r]*T[i];
        return b;
      };
      const rR=solve4x4(G,makeB(Tr));
      const rG=solve4x4(G,makeB(Tg));
      const rB=solve4x4(G,makeB(Tb));
      return (rR && rG && rB) ? [rR,rG,rB] : null;
    }

    function applyRecolor(srcCanvas, T) {
      const [rR, rG, rB] = T;
      const cCtx = srcCanvas.getContext('2d');
      const id = cCtx.getImageData(0,0,srcCanvas.width,srcCanvas.height);
      const d = id.data;
      const thr = (WHITE_THRESHOLD/100)*255;
      
      for(let i=0; i<d.length; i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        let nr = rR[0]*r + rR[1]*g + rR[2]*b + rR[3];
        let ng = rG[0]*r + rG[1]*g + rG[2]*b + rG[3];
        let nb = rB[0]*r + rB[1]*g + rB[2]*b + rB[3];
        nr = nr>255?255:(nr<0?0:nr);
        ng = ng>255?255:(ng<0?0:ng);
        nb = nb>255?255:(nb<0?0:nb);
        if (0.299*nr + 0.587*ng + 0.114*nb >= thr) { nr=255; ng=255; nb=255; }
        d[i]=nr; d[i+1]=ng; d[i+2]=nb;
      }
      const out = document.createElement('canvas');
      out.width=srcCanvas.width; out.height=srcCanvas.height;
      out.getContext('2d').putImageData(id,0,0);
      return out;
    }

    function renderList() {
      els.list.innerHTML = '';
      const count = STATE.pages.length;
      if (els.pageSummary) {
        els.pageSummary.textContent = count
          ? (count === 1 ? '1 page' : count + ' pages')
          : 'No pages';
      }

      if(!count) {
        els.list.innerHTML = `<div id="msgEmpty" style="width:100%; text-align:center; padding:20px; color:var(--text-sub); font-size:13px;">No pages</div>`;
        return;
      }
      STATE.pages.forEach((p, i) => {
        const card = document.createElement('div');
        card.className = `page-card ${i === STATE.currentIdx ? 'active' : ''}`;
        card.innerHTML = `
          <span class="material-symbols-rounded drag-handle">drag_indicator</span>
          <img src="${p.thumbUrl}" class="thumb">
          <div class="info">
            <div class="filename">${p.name}</div>
            <div class="page-meta">Page ${i+1}</div>
          </div>
          <button class="btn-del" aria-label="Delete page ${i+1}"><span class="material-symbols-rounded" style="font-size:18px">delete</span></button>
        `;
        card.onclick = (e) => { if(!e.target.closest('.btn-del')) selectPage(i); };
        card.querySelector('.btn-del').onclick = (e) => {
          e.stopPropagation();
          if(confirm('Delete page?')) {
            STATE.pages.splice(i, 1);
            if(!STATE.pages.length) {
              STATE.currentIdx = -1;
              els.paper.style.display = 'none';
              els.empty.style.display = 'flex';
              $('exportBtn').disabled = true;
              $('cropBtn').disabled = true;
              $('autoCropBtn').style.display = 'none';
              $('stencilBtn').disabled = true;
              $('stencilBtn').classList.remove('active');
              STATE.isStencilMode = false;
              resetZoom();
            } else {
              STATE.currentIdx = Math.max(0, Math.min(STATE.currentIdx, STATE.pages.length - 1));
              selectPage(STATE.currentIdx);
            }
            renderList();
          }
        };
        els.list.appendChild(card);
      });
    }

    let dragPt = -1;
    
    // --- MOUSE EVENTS FOR CROP ---
    els.canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', handleEnd);

    // --- TOUCH EVENTS FOR CROP ---
    els.canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      handleStart(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    window.addEventListener('touchmove', e => {
      if(dragPt !== -1) e.preventDefault();
      handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    window.addEventListener('touchend', handleEnd);


    function handleStart(cx, cy) {
      if(STATE.currentIdx < 0) return;
      const p = STATE.pages[STATE.currentIdx];
      const rect = els.canvas.getBoundingClientRect();
      const scaleX = els.canvas.width / rect.width;
      const scaleY = els.canvas.height / rect.height;
      const x = (cx - rect.left) * scaleX;
      const y = (cy - rect.top) * scaleY;
      
      let min = Infinity;
      p.quad.forEach((pt, i) => {
        const d = Math.hypot(pt.x - x, pt.y - y);
        if(d < min) { min = d; dragPt = i; }
      });
      const hitRadiusPct = (window.innerWidth <= 768) ? 0.12 : 0.05;
      const hitArea = els.canvas.width * hitRadiusPct;
      
      if(min > hitArea) dragPt = -1;
      if(dragPt !== -1) updateMagnifier(p.quad[dragPt].x, p.quad[dragPt].y);
    }

    function handleMove(cx, cy) {
      if(dragPt === -1) return;
      const p = STATE.pages[STATE.currentIdx];
      const rect = els.canvas.getBoundingClientRect();
      const scaleX = els.canvas.width / rect.width;
      const scaleY = els.canvas.height / rect.height;
      let x = (cx - rect.left) * scaleX;
      let y = (cy - rect.top) * scaleY;
      x = Math.max(0, Math.min(els.canvas.width, x));
      y = Math.max(0, Math.min(els.canvas.height, y));
      p.quad[dragPt] = {x, y};
      requestAnimationFrame(drawCropCanvas);
      updateMagnifier(x, y);
    }

    function handleEnd() {
      dragPt = -1;
      els.magnifier.style.display = 'none'; 
    }

    function setTheme(mode) {
      STATE.theme = mode;
      if(mode === 'dark') {
        document.body.classList.add('dark-mode');
        $('themeBtn').innerHTML = '<span class="material-symbols-rounded">light_mode</span>';
      } else {
        document.body.classList.remove('dark-mode');
        $('themeBtn').innerHTML = '<span class="material-symbols-rounded">dark_mode</span>';
      }
      localStorage.setItem('theme', mode);
      if(STATE.isCropMode) drawCropCanvas();
    }
    $('themeBtn').onclick = () => setTheme(STATE.theme === 'dark' ? 'light' : 'dark');

    const loadImage = (file) => new Promise(r => {
      const img = new Image();
      img.onload = () => r(img);
      img.src = URL.createObjectURL(file);
    });

    const canvasToUrl = (c) => new Promise(r => c.toBlob(b => r(URL.createObjectURL(b))));

    function resizeCanvas(c, w) {
      const t = document.createElement('canvas');
      const ratio = c.height / c.width;
      t.width = w; t.height = w * ratio;
      t.getContext('2d').drawImage(c, 0, 0, t.width, t.height);
      return t;
    }

    function showToast(msg) {
      const t = $('toast'); t.textContent = msg; t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2000);
    }

    $('exportBtn').onclick = async () => {
      if(!STATE.pages.length) return;
      showToast('Generating PDF...');
      await new Promise(r=>setTimeout(r,100));
      
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      const pdfW = doc.internal.pageSize.getWidth();
      const pdfH = doc.internal.pageSize.getHeight();

      for(let i=0; i<STATE.pages.length; i++) {
        if(i>0) doc.addPage();
        const p = STATE.pages[i];
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = p.processed.width;
        tempCanvas.height = p.processed.height;
        const tCtx = tempCanvas.getContext('2d');
        
        tCtx.drawImage(p.processed, 0, 0);
        
        if(STATE.isStencilMode || p.marker) {
            drawOverlay(tCtx, tempCanvas.width, tempCanvas.height, true);
        }

        const ratio = Math.min(pdfW / tempCanvas.width, pdfH / tempCanvas.height);
        const w = tempCanvas.width * ratio;
        const h = tempCanvas.height * ratio;
        const data = tempCanvas.toDataURL('image/jpeg', 0.8);
        doc.addImage(data, 'JPEG', (pdfW-w)/2, (pdfH-h)/2, w, h);
      }
      
      doc.save(($('docTitle').value || 'scan') + '.pdf');
      showToast('PDF Downloaded');
    };

    $('cropBtn').onclick = toggleCropMode;
    $('autoCropBtn').onclick = autoCrop;
    $('stencilBtn').onclick = toggleStencilMode;
  </script>
</body>
</html>
